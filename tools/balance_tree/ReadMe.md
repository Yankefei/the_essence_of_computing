```sh
B树的版本为：所有的数据头存储在树叶上，也就是非叶子节点的索引值均可以在叶子节点中找到, B树的阶在
构造时作为参数传入。
这里实现的版本为Robert Sedgewich所提供的版本, 并非Mark Allen Weiss和国内教科书作者如严蔚敏等
所提供的版本。

该版本的特点为：（B树的阶为M）
1. 所有的数据均存储在叶子节点上，接近B+树的结构。
2. 当非叶子节点内的元素个数为m个时，那么它下级的节点个数也是m个，而不是类似 2-3-4树那样定义的m+1
   个节点。
3. 节点内元素中存储的值为下级各节点中存储值的最小值，而不是最大值。
4. 存在叶子节点的情况下，根节点的元素最小值为2，其他节点的元素最小值为M/2（向上取整）到M。如3阶非根节点
   的元素数为2-3个，4阶非根节点的元素数为2-4个，5阶非根节点的元素数为3-5个。

下面是一棵3阶B树的示意图：

                                10-63
                            /              \
                    10-21-51              63-81
                /     |     \             /    \
            10-15  21-37-44   51-59     63-72   81-91-97


本文件夹 balance_tree 内，实现了B树4个版本的代码，分别是:

1. 没有parent_指针的递归插入，删除版本
2. 没有parent_指针的非递归插入，删除版本（额外实现了c++四组拷贝构造函数和赋值语句重载函数，含右值引用版本）
3. 携带parent_指针的递归插入，删除版本
4. 携带parent_指针的非递归插入，删除版本（额外实现了c++四组拷贝构造函数和赋值语句重载函数，含右值引用版本）



与 balance_tree_debug 版本的区别在于B树的Node节点中，使用普通数组存放Entry数据还是还是使用指针
数组来存放。非debug的版本使用了指针数组的形式来存放Entry数据的指针。好处有两点：

1. 在插入，删除过程中，如果需要在Node节点内以及Node节点间转移Entry数据时，转移指针是最优选择，如果
   使用普通的Entry数组，则需要额外的对象赋值操作，这个是主要考虑的点。
2. 使用指针数组的形式，可以在模板类型T本身内存较大时，去掉一次性大块内存数组申请的需要。

    --Yankefei
```